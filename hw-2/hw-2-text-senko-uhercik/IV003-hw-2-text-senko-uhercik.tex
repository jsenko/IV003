%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
% \usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[slovak]{babel} % Slovak language/hyphenation
\usepackage[utf8]{inputenc}
% \usepackage[IL2]{fontenc}
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{algpseudocode}
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
\normalfont \normalsize 
\textsc{IV003, Fakulta Informatiky, Masarykova Univerzita} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge Homework 2 \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Jakub Senko, Štefan Uherčík} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	Príklad 1
%----------------------------------------------------------------------------------------

\section*{Príklad 1}

Zaveďme všeobecnú reprezentáciu budov. Každá uvažovaná budova sa dá reprezentovať ako množina dvojíc $(x_k, h_k)$, určujúcich výšku budovy $h$ na súradnici $x$. Zápis sa dá zjednodušiť usporiadaním bodov vzostupne podľa $x$. Stačí uvažovať len tie dvojice, ktoré označujú miesto, v ktorom nastáva zmena výšky budovy. Tento zápis je ekvivalentný so zápisom použitým v zadaní

\begin{equation}
    \begin{aligned}
        (1, \boldsymbol{5}, 5) \sim ((1, 5), (5, 0)) \\
    \end{aligned}
\end{equation}

ide len o vnútornú reprezentáciu za účelom zjednodušenia algoritmu. \\
\\

\subsection*{Merge}

Uvažujme algoritmus MERGE, ktorý z reprezentácie dvoch budov vypočíta reprezentáciu ich siluety. \\
\\
Algoritmus využíva object BUILDING\_ITERATOR pomocou ktorého je možné postupne prechádzat reprezentáciou danej budovy. Obsahuje tri  metódy. \\
NEXT\_COORDINATE\_EXISTS a NEXT\_COORDINATE\_POSITION sú triviálne a neposúvajú pozíciu iterátora. Tretia metóda, GET\_HEIGHT($x$) vráti výšku budovy na zadanej súradnici. Táto metóda spôsobí dostatočný posun iterátora v prípade, že zadaná pozícia je väčšia alebo rovná ako NEXT\_COORDINATE\_POSITION. Kedže iterátor je jednorázový, túto metódu je nie je možné zavolať s argumentom menším ako v predchádzajúcom volaní. Iterátor si jednoducho pamätá poslednú výšku. \\
\\
Samotný MERGE pracuje s dvoma iterátormi, pre každú budovu jeden a výstup postupne ukladá do samostatného zoznamu. Základom je {\em while} smyčka, ktorá sa vykoná ak aspoň pre jeden s iterátorov platí NEXT\_COORDINATE\_EXISTS.
Algoritmus potom vybere menšie $x$ z NEXT\_COORDINATE\_POSITION a zavolá metódu GET\_HEIGHT na oboch iterátoroch. Následne vybere väčšiu z výšok, $h$ a zavolá funkciu TRY\_ADD, ktorá jednoducho vloží novú súradnicu $(x, h)$ do výsledného zoznamu v prípade, že sa výška siluety zmenila (čo nemusí nastať). \\
\\
Tento algoritmus funguje pre ľubovolné reprezentácie s dĺžkou $n_1, n_2$ v čase $\mathcal{O}(n_1 + n_2)$, čo je $\mathcal{O}(n)$ pre budovy s rovnako veľkou reprezentáciou. Zdôvodnenie je jednoduché - využíva jednosmerný iterátor na jedno použitie pre  každú reprezentáciu - a teda každú súradnicu spracuje práve raz. Algoritmus je konečný pretože pri každom priechode cyklom metóda GET\_HEIGHT posunie aspoň jeden z iterátorov. \\
\\

\subsection*{Rozdeľ a panuj}

Výslednú siluetu dosiahneme aplikovaním funkcie MERGE na vhodné podproblémy. Toto delenie funguje rovnako ako pri algoritme {\em merge sort}. Funkcia COMPUTE\_SILHOUETTE zoberie ako argument množinu reprezentácii budov. Ak táto množina obsahuje jednu budovu, tak ju vráti. Ak dve budovy, zavolá na nich MERGE a vráti výsledok. Ak viac, rozdelí množinu na dve rovnaké (s rozdielom jednej budovy v prípade nepárneho počtu) množiny, rekurzívne sa na oboch zavolá a výsledok znovu spojí pomocou MERGE a vráti. Týmto spôsobom funkcia COMPUTE\_SILHOUETTE vždy vráti merge všetkých spojich argumentov (merge nezávisí na poradí). \\
\\
Zložitosť závisí na počte MERGE operácii a veľkosti ich vstupu. Na každej úrovni rekurzie je suma veľkosti všetkých reprezentácií rovnaká ($n$ dĺžky 2 na začiatku vs dve dlhé $n$ na konci, kde $n$ je počet budov) a počet úrovní je $\log_2 n$. Výsledná zložitosť je teda $\mathcal{O}(n \log n)$

\pagebreak

%----------------------------------------------------------------------------------------
%	Príklad 2
%----------------------------------------------------------------------------------------

\section*{Príklad 2}

Algoritmus vykoná všetky možné rozdelenia vstupného reťazca na 2 časti, prefix a suffix.
Ak je daný reťazec veta, existuje aspoň jedno rozdelenie také, že suffix je slovo a prefix je znovu veta.
Tento test sa vykoná v tele cyklu, kde sa rekurzívne použije IS\_SENTENCE na danom prefixe vstupného slova.
Premenná $result$ je true práve vtedy ak je aspoň jeden z týchto testov je true.

\begin{algorithmic}[1]
    \Function{is\_sentence}{$w[1 \dots n]$}
        \State result = IN\_DICTIONARY($w[1 \dots n$]);
        \For{$i = 1 \dots n$}
        	\State item = IS\_SENTENCE($w[1 \dots i]$) $\wedge$ IN\_DICTIONARY($w[i + 1 \dots n]$);
		\State result = result $\vee$ item;
        \EndFor
        \State \Return result;
    \EndFunction
\end{algorithmic}
\ \\

Pri každom z rekurzívnych volaní je argument funkcie IS\_SENTENCE {\em vždy prefixom} argumentu volajúcej funkcie.
Pri tomto rekurzívnom algoritme môže existovať v strome rekurzie viacero ciest k volaniu IS\_SENTENCE s rovnakým argumentom, avšak každý reťazec má konečné množstvo prefixov, konkrétne $n - 1$.
Preto stačí vykonať iba lineárne množstvo volaní.
Tieto volania sa dajú {\em usporiadať} tak, že sa funkcia postupné volá pre rastúci prefix. 
Táto myšlienka je základom nasledujúcej dynamickej varianty funckie IS\_SENTENCE.\\

Predstavme si nasledovný prípad
Na vstup dostane algoritmus reťazec o dĺžke n.
Pri overovaní jednotlivých rozdelení nájde slovo o dĺžke a (a zároveň sa rekurzívne zanorí na prefixe o dĺžke (n-a)) a ďalej pokračuje v overovaní ďalších rozdelení (s prefixami dĺžky (n-a+1),(n-a+2),...).

Algoritmus sa rekurzívne zavolá na reťazci o dĺžke n-a.
Pri týchto volaniach však overuje prefixy s dĺžkami 1 .. n-a. Tieto prefixy však overoval aj predošlý priechod algoritmu.

Môžeme povedať, že volanie funkcie IS\_SENTENCE aplikované na reťazci dĺžky n je závislé na všetkých možných volaniach funkcie IS\_SENTENCE aplikovaných na prefixoch tohto reťazca.

Z tohoto dôvodu je výhodné, ak vypočítame IS\_SENTENCE na prefixoch pôvodného reťazca a výsledky týchto volaní si uložíme do rovnomenného asociatívneho poľa.
Kľúč tohto poľa bude tvorený prefixom pôvodného reťazca, hodnota bude typu boolean.


\begin{algorithmic}[1]
    \Function{is\_sentence}{$w[1 \dots n]$}
    \For{$i = 1 \dots n$}
        \State result = IN\_DICTIONARY($w[1 \dots i]$);
        \For{$j = 1 \dots i - 1$}
                \State item = SENTENCE\_DATA($w[1 \dots j]$) $\wedge$ IN\_DICTIONARY($w[j + 1 \dots i - 1]$);
		\State result = result $\vee$ item;
        \EndFor
	\EndFor
	\State \Return result;
    \EndFunction	
\end{algorithmic}
\ \\
 
Korektnosť: 

Konvergencia:
Prvy cyklus sa vykoná pre každý prefix slova w.
V cykle sa hodnota premennej i reprezentujucej dlžku prefixu pri každom priechode zvýši o 1 a iterovanie skončí, keď premenná i dosiahne hodnotu n.

Vnorený cyklus sa vykoná pre každý prefix tohto prefixu. 

Jediné miesta, u ktorých hrozí, že algoritmus nezastaví, sú volania cyklov.

V cykle s iterujúcou premennou j sa zaručene pri každom priechode zvýši hodnota premennej j a iterovanie skončí, keď premenná j dosiahne hodnotu i-1.

Parciálna korektnosť:
Dôkaz, že algoritmus vráti true pri validnej postupnosti slov pomocou matematickej indukcie:
1.) S0 = w0 je veta ktorá sa skladá z jedného slova w0 (w0 sa nachádza v slovníku). Pre takúto vetu vráti algoritmus true. Dôvod: položky subresults pre prvok IS\_SENTENCE(w0) budú obsahovať položku dict(w0), ktorá sa vyhodnotí na true. Na položky je aplikovaná funkcia logiký súčet a pretože obsahujú minimálne jednu položku z hodnotou true, algoritmus vráti true.
	
2.) Predpokladáme, že pre vetu s1 zloženú z k slov: s1 = w1.w2...wk vráti korektnú odpoveď true.
	Predpokldáme, že pre vetu s2 zloženú s2 = s1.w(k +1) algoritmus taktiež vráti true.
	Jeden z prefixov vety s2 musí byť reťazec zložený zo slov w1...wk.
	Keďže algoritmus prechádza všetky prefixy, nastane situácia, jedna z položiek v poli subresults
	pre prvok s2 bude IS\_SENTENCE(s1) logical\_and dict(w(k+1)).
	
	
Dôkaz, že algoritmus vráti true pri nevalidnej postupnosti slov

	
	
	
	
	
	



 
Zložitosť:
Cyklus s iterujúcou premennou i bude vykonaný n krát.

Vnorený cyklus s iterujúcou premennou j bude vykonaný (i-1) krát, a plaží, že (i-1) < n. Všetky operácie použité v ňom majú konštantnú zložitosť.
Volanie apply logical\_or on subresults bude mať rovnakú zložitosť ako vnorený cyklus (vzhľadom k tomu, že počet jeho položiek zodpovedá počtu iterácií).

$\mathcal{O}(n^2)$

\pagebreak

%----------------------------------------------------------------------------------------
%	Príklad 3
%----------------------------------------------------------------------------------------

\section*{Príklad 3}

Vstupom algoritmu bude:
pole pravdepodobností: $C[p(1),..,p(n)]$\\
$k$ - počet padnutých orlov\\
PVD - pravdepodobnostná funkcia\\
n
Problém je možné definovať nasledovne: 
vypočíť pravdepodobnosť, že v poli padne k orlov z n mincí

táto pravdepodobnosť je ekvivaletná súčtu pravdepodobností nasledovných prípadov:

1.) pravdepodobnosť prípadu, že posledná minca bude orol
táto pravdepodobnosť je ekvivalentná súčinu čísla p(n) a pravdepodobnosti, že medzi prvými n-1 mincami bude k-1 orlov

2.) pravdepodobnosť prípadu, že posledná minca nebude orol
táto pravdepodobnosť je ekvivalentná súčinu čísla (1-p(n)) a pravdepodobnosti, že medzi prvými n-1 mincami bude k orlov

Tento poznatok nám umožňuje definovať jednoduchý rekurzívny algoritmus (v ktorm zároveň ošetrujeme krajné prípady n=k a n=0)

\begin{algorithmic}[1]
    \Function{PVD}{C[p1,..,pn],k}
        \If{k=0}
            \State \Return PVD(C[p(1),..,p(n-1)],0)*(1-p(n));
        \EndIf
        \If{k=n}
            \State \Return PVD(C[p(1),..,p(n-1)],k-1)*p(n);
        \EndIf
        \State \Return PVD(C[p(1),..,p(n-1)],k-1)*p(n) + PVD(C[p(1),..,p(n-1)],k)*(1-p(n));
    \EndFunction
\end{algorithmic}
\ \\

Ak rozpíšeme vetvenie algoritmu vykonávanie bude vyzerať približne nasledovne
PVD(C[p(1),..,p(n)],k) = PVD(C[p(1),..,p(n-1)],k-1)*p(n) + PVD(C[p(1),..,p(n-1)],k)*(1-p(n))

PVD(C[p(1),..,p(n-1)],k) = PVD(C[p(1),..,p(n-1)],k-1)*p(n-1) + PVD(C[p(1),..,p(n-1)],k)*(1-p(n-1))

PVD(C[p(1),..,p(n-1)],k-1) = PVD(C[p(1),..,p(n-1)],k-2)*p(n-1) + PVD(C[p(1),..,p(n-1)],k-1)*(1-p(n-1))

...
Z predchádzajúceho zápisu volaní funkcií je možné vidieť, že PVD(C[p(1),..,p(n-1)],k-1) sa zavolá 2 krát na jednej úrovni rekurzívneho stromu.
Využijeme techniku dynamického programovania, aby sme sa vyhli opakovanému volaniu funkcie PVD na rovnakých parametroch.
Z algoritmu je zreteľné, že volanie funkcie PVD, ktorá berie ako parameter pole o dĺžke a, je závislá výlučne na volaniach funkcií PVD, ktoré berú ako parameter pole o dĺžke a-1.
Z tohoto dôvodu je výhodné, ak vypočítame najprv. funkcie s parametrami PVD(C[p(1)],0), PVD(C[p(1)],1), PVD(C[p(1),p(2)],0),... ,ich výsledky si budem ukladať do asociatívneho poľa a postupným volaním sa dopracujem k hodnote PVD(C[p(1),..,p(n)],k), ktorá je výsledkom celého problému.
Pre tento účel vytvoríme asociatívne pole s názvom PVD, v ktorom kľúče budú mať tvar:
(C[p(1),..,p(n)],k)
a hodnoty budú obsahovať napočítanú pravdepodobnosť.
Na naplnenie tohto poľa vytvoríme jednoduchú nerekurzívnu funkciu:


\begin{algorithmic}[1]
	\Function{countPVD}{C[p1,..,pn],k}
		\State PVD([p(1)],0) = p1
		\State PVD([p(1)],1) = (1-p1);

		\For{i = 1 .. n}
			\State bottom = max(0,k-(n-i));
			\State up = min(i,k);
			\For{j = bottom .. up}
				\If{k=0}
					\State PVD(C[p(1),..,p(i-1)],0)*(1-p(i));
				\Else \If{k=n}
					\State PVD(C[p(1),..,p(i-1)],j-1)*p(i);
				\Else 
					\State PVD(C[p(1),..,p(i-1)],j-1)*p(i) + PVD(C[p(1),..,p(i-1)],j)*(1-p(i));
				\EndIf \EndIf
			\EndFor
		\EndFor
		\State \Return PVD(C[p(1),..,p(n-1)],k);
	\EndFunction
\end{algorithmic}
\ \\
Zložitosť:
Cyklus s iterujúcou premennou i sa vykoná n krát.
V ňom sa vnorený cyklus iterujúcou premennou j vykoná vždy (up - bottom) krát.
V každom cykle bude hodnota premennej bottom minimálne 0 a hodnota premennej up maximálne k, z čoho vyplýva, že počet týchto cyklov bude maximálne k.
Je zaručené, že k < n a teda zložitosť celého algoritmu bude patriť do triedy $\mathcal{O}(n^2)$


\pagebreak

%----------------------------------------------------------------------------------------
%	Príklad 4
%----------------------------------------------------------------------------------------

\section*{Príklad 4}

rekurzívny algoritmus

Cenu optimálneho rozdelenie áut do autosalónov je možné vypočítať pomocou jednoduchécho rekurzívneho algoritmu.
Číslo auta je zároveň jeho index riadku v matici cien.
Parameter n v algoritme bestPrice udáva počet áut ktoré ešte neboli priradené do autosalónu a kedže sa autá priradujú postupne, tak udáva zároveň aj číslo nasleujúceho nepriradeného auta.
Parameter freePlaces udáva počet neobsadených miest v jednotlivých autosalónoch (číslo na indexe i v tomto poli udáva počet volných miest v autosalóne i).
V každom rekurzívnom volaní priradíme auto do každého autosalónu az týchto priradení vrátime maximálnu cenu.
Rekurzia sa zastaví v prípade že sme priradili už všetky autá.
Predpokladáme že počet áut je delitelný počtom autsalónov.

\begin{algorithmic}[1]
\Function{best\_price}{n,freePlaces[]}
    \If{n == 0}
        \State \Return 0
    \EndIf

    \State values = [] of number

    \For{i = 1 .. freePlaces.size} 		
        \If{freePlaces[i] != 0}		
            \State freePlacesCopy = copy of freePlaces;			
            \State	freePlacesCopy[i] = freePlacesCopy[i] - 1;			
            \State values[i] = best\_price(n-1,freePlacesCopy) + C[n][i];
        \EndIf
    \EndFor

    \State \Return max(values);
\EndFunction
\end{algorithmic}

\subsection*{Technika dynamického programovania}

Každé volanie funkcie bestPrice na matici s počtom riadkov k potrebuje  výsledky volaní funkcie betPrice na matici s počtom riadkov k-1. Toto nám jasne definuje závislosť  a teda možné usporiadanie volaní.

Vytvorím štruktúru bestPriceData, ktorá  bude mať typ asociatívneho poľa asociatívnych polí.


Vonkašie asociatívne pole (BestPriceData)
kľúč index riadku v matici C
hodnota bude pole dvojíc PricesForFreePlaces

Štruktúra PricesForFreePlaces takisto asociatívne pole
kľúč bude typu freePlaces (pole čísel)
hodnota bude typu price, číslo



Aby sme zaznamenali všetky možné kombinácie parametrov n a freePlaces, vo funkcii bestPrice sme vytvorili funkciu findSpecialPermutations. Táto funkcia vráti všetky možnosti ako môže vyzeraž pole freePlaces pre sum áut v prípade že do jedného autosalónu môžeme daž maximálne threshold áut.

\begin{algorithmic}
\Function{findSpecialPermutations}{sum,threshold} 
	\If{sum = 0}
		\State \Return [0,0,0]
	\EndIf
	\State permutations = [] of [];
	\State bottom1 = max(0,sum - 2*threshold);
	\State upper1 = min(sum,threshold);
	
	\For{ i = bottom1 .. upper1 }
		\State permutation = [] of length 3
		\State permutation[1] = i;
		
		\State bottom2 = max(0,sum - i - threshold);
		\State upper2 = min(sum - i,threshold);
		
		\For{j=bottom2 .. upper2}
			\State permutation[2] = j;
			\State permutation[3] = sum - (i+j);
		\EndFor
		
		
		permutations.add(permutation);
	\EndFor
	\State \Return permutations;
\EndFunction
\end{algorithmic}

\ \\

Nasledovná nerekurzívna funkcia postupne priradí do štruktúry bestPriceData hodnoty najlepších možných cien pre danú konfiguráciu.
Vonkajší for cyklus s iterujúcou premennou i v každom priechode spocita maximalne ceny pre vsešetky distribucie pr i aut.
Využívame hodnoty v bestPriceData vypočítané v predchádzajúcih priechodoch cyklom.


\begin{algorithmic}[1]
\Function{countBestPrice}{C}
    \State bestPriceData[ (0, [0,0,0]) ] = 0;
    \For{i = 1 .. C.rows}				
        \State permutations = findSpecialPermutations(i,C.rows/3);
	
		
        \For{permutation in permutations}		
            
            \State items = [] of number;
            
	    \For{ j = 1 .. permutation.size}
	    	
                \State modifiedPermutation = copy of permutation
		\If{modifiedPermutation[j]>0}
		    \State modifiedPermutation[j] = modifiedPermutation[j] - 1;
		    \State items.add(bestPriceData[(i-1,modifiedPermutation)] + C[i][j]);
                 \EndIf
            \EndFor			
		
            \State bestPriceData[(i,permutation)] = max(items);		
        \EndFor
    \EndFor
    \State \Return bestPriceData[C.rows,[C.rows/3,C.rows/3,C.rows/3]];
\EndFunction
\end{algorithmic}

Konvergencia
Algoritmus môže nekonvergovať len pri vyhodnotení podmienky jedného z troch cyklov.
Cyklus s iterujúcou premennou j sa skončí pretože permutation.size je kladná konštanta.
Cyklus s iterujúcou premennou permutation skončí pretože funkcia findSpecialPermutations vráti konečný počet položiek.
Vonkajší cyklus pretože C.rows je kladná konštanta.


Parciálna korektnosť
Dokážeme matematickou indukciou podla počtu áut pre ktorý sme už vypočítali maximalnu cenu (vonkajší cyklus).

Bázovy krok
Pre i = 0
Táto situácia je riešená pred cyklom naplnením pola bestPriceData hodnotou (0, [0,0,0]).

Indukčný krok:
Pre i = k
Predpokladáme že bestPriceData obsahuje správne vypočítané maximálne ceny pre všetky možné konfigurácie freePlaces pre počet áut k , označme ich currentFreePlaces.
Vnútorný for cyklus s iterujúcou premennou permutation vypočíta maximálne ceny pre všetky možné konfigurácie freePlaces. Každá maximálna cena sa vypočíta ako maximum z už vypočítaných konfigurácii.
Pretože for cyklus prebehne pre všetky možné permutácie pre k áut, budú dostupné pre k+1 iteráciu cyklu.

Pre krátkost tento algoritmus počíta len výšku najlepšej ceny za akú je možné autá predať, ale je triviálne modfikovatelný aby si spolu s cenou pametal aj konkretne priradenie aut do autosalonov.
Namiesto ceny je stačí uložiť do bestPriceData dvojicu (cena, priradenie). Priradenie je pole o dlžke C.rows a hodnota na indexe i v tomto poli vyjadruje číslo autosalónu do ktorého bude auto priradené, prípadne 0 ak eťe nie je priradené.

Nasledujúci algoritmus toto implementuje:

Zložitosť
funkcia findSpecialPermutations
vo funkcii sa nachádzajú dva cykly:
počet vykonaní prvého cyklu je (upper1 - bottom1), rozdiel týchto premenných bude vždy menší ako počet áut.
Ekvivalentné tvrdenie môžeme spraviť pre druhý cyklus s počtom vykonaní (upper1 - bottom1).
Každá operácia použitá v cykloch má konštantnú zložitosť, preto je jej celková zložitosť $\mathcal{O}(n^2)$.

funkcia countBestPrice
vonkajší cyklus sa vykoná pre každé auto práve raz, teda C.row krát.

Zo zložistosti funkcie findSpecialPermutations môžeme povedať, že počet prvkov v poli permutations je maximálne kvadraticky závislý na premennej i.

Zložitosť operácií v cykle s iterujúcou premennou j je konštatný, vzhľadom na to, že hodnota permutation.size zodpovedá počtu autosalónov a ten je konštantný počas celého vykonávania programu.
Zložitosť cyklu s iterujúcou premennou permutation má preto zložitosť $\mathcal{O}(n^2)$ (kvôli počtu prvkov v poli permutations).

Predošlé tvrdenia môžeme zredukovať na tvrdenie, že v cykle s iterujúcou premennou i sa vždy vykonajú dve operácie so zložitosťou $\mathcal{O}(n^2)$.
Jeho zložitosť je teda $\mathcal{O}(n^3)$.


\begin{algorithmic}[1]
\Function{countBestPrice}{C}
    bestPriceData[(0,[0,0,0])] = 0;
    \For{i = 1 .. C.rows}		
        \State permutations = findSpecialPermutations(i,C.rows/3);
				
        \For{permutation in permutations}		
            \State items = [] of item (price -> number, distribution -> [] of number); 
            
	    \For{ j = 1 .. permutation.size}
                \State modifiedPermutation = copy of permutation
		\If{modifiedPermutation[j]>0}
		    \State modifiedPermutation[j] = modifiedPermutation[j] - 1;
		    \State	item it;
		    \State aPrice = bestPriceData[(i-1,modifiedPermutation)];
		    \State it.price = aPrice.price + C[i][j];
		    \State it.distribution = aPrice.distribution;
		    \State it.distribution[i] = j;
                    \State items.add(it);
                 \EndIf
            \EndFor			
		
            \State highestPriceIndex = index into items for item with highest price;
            \State bestPriceData[(i,permutation)] = items[highestPriceIndex];		
        \EndFor
    \EndFor
     \State \Return bestPriceData[C.rows,[C.rows/3,C.rows/3,C.rows/3]];
\EndFunction
\end{algorithmic}

Algoritmus je rozšíriteľný pre väčší počet autosalónov, je však potrebné zmeniť implementáciu funkcie findSpecialPermutations.

\pagebreak

%----------------------------------------------------------------------------------------
%	Príklad 5
%----------------------------------------------------------------------------------------

\section*{Príklad 5}

Hladový algoritmus nenájde správne riešenie pre druhý a tretí problém. \\
Protipríklad: \\
Dokument s dĺžkou riadku: 12 \\
Zoznam slov obsahuje slová s dĺžkami 5,4,4,12 \\

Algoritmus umiestni slová nasledovne: \\
5,4 \\
4 \\
12 \\

Druhý slovný problém: \\
Celková penalizácia bude $3^2 + 8^2 + 0 = 9 + 64 = 73$ \\

Optimálne riešenie je však: \\
5 \\
4,4 \\
12 \\
pri ktorom bude celková penalizácia $7^2 + 4^2 = 49 + 16 = 64$ \\

Tretí slovný problém: \\
Celková penalizácia bude: max(3,8,0) = 8 \\

Optimálne riešenie je však: \\
5 \\
4,4 \\
12 \\
pri ktorom bude celková penalizácia max(7,4,0) = 7 \\

\end{document}
