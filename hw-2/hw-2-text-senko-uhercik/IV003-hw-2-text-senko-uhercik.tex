%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
% \usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[slovak]{babel} % Slovak language/hyphenation
\usepackage[utf8]{inputenc}
% \usepackage[IL2]{fontenc}
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{algpseudocode}
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
\normalfont \normalsize 
\textsc{IV003, Fakulta Informatiky, Masarykova Univerzita} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge Homework 2 \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Jakub Senko, Štefan Uherčík} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	Príklad 1
%----------------------------------------------------------------------------------------

\section*{Príklad 1}

Zaveďme všeobecnú reprezentáciu budov. Každá uvažovaná budova sa dá reprezentovať ako množina dvojíc $(x_k, h_k)$, určujúcich výšku budovy $h$ na súradnici $x$. Zápis sa dá zjednodušiť usporiadaním bodov vzostupne podľa $x$. Stačí uvažovať len tie dvojice, ktoré označujú miesto, v ktorom nastáva zmena výšky budovy. Tento zápis je ekvivalentný so zápisom použitým v zadaní

\begin{equation}
    \begin{aligned}
        (1, \boldsymbol{5}, 5) \sim ((1, 5), (5, 0)) \\
    \end{aligned}
\end{equation}

ide len o vnútornú reprezentáciu za účelom zjednodušenia algoritmu. \\
\\

\subsection*{Merge}

Uvažujme algoritmus MERGE, ktorý z reprezentácie dvoch budov vypočíta reprezentáciu ich siluety. \\
\\
Algoritmus využíva object BUILDING\_ITERATOR pomocou ktorého je možné postupne prechádzat reprezentáciou danej budovy. Obsahuje tri  metódy. \\
NEXT\_COORDINATE\_EXISTS a NEXT\_COORDINATE\_POSITION sú triviálne a neposúvajú pozíciu iterátora. Tretia metóda, GET\_HEIGHT($x$) vráti výšku budovy na zadanej súradnici. Táto metóda spôsobí dostatočný posun iterátora v prípade, že zadaná pozícia je väčšia alebo rovná ako NEXT\_COORDINATE\_POSITION. Kedže iterátor je jednorázový, túto metódu je nie je možné zavolať s argumentom menším ako v predchádzajúcom volaní. Iterátor si jednoducho pamätá poslednú výšku. \\
\\
Samotný MERGE pracuje s dvoma iterátormi, pre každú budovu jeden a výstup postupne ukladá do samostatného zoznamu. Základom je {\em while} smyčka, ktorá sa vykoná ak aspoň pre jeden s iterátorov platí NEXT\_COORDINATE\_EXISTS.
Algoritmus potom vybere menšie $x$ z NEXT\_COORDINATE\_POSITION a zavolá metódu GET\_HEIGHT na oboch iterátoroch. Následne vybere väčšiu z výšok, $h$ a zavolá funkciu TRY\_ADD, ktorá jednoducho vloží novú súradnicu $(x, h)$ do výsledného zoznamu v prípade, že sa výška siluety zmenila (čo nemusí nastať). \\
\\
Tento algoritmus funguje pre ľubovolné reprezentácie s dĺžkou $n_1, n_2$ v čase $\mathcal{O}(n_1 + n_2)$, čo je $\mathcal{O}(n)$ pre budovy s rovnako veľkou reprezentáciou. Zdôvodnenie je jednoduché - využíva jednosmerný iterátor na jedno použitie pre  každú reprezentáciu - a teda každú súradnicu spracuje práve raz. Algoritmus je konečný pretože pri každom priechode cyklom metóda GET\_HEIGHT posunie aspoň jeden z iterátorov. \\
\\

\subsection*{Rozdeľ a panuj}

Výslednú siluetu dosiahneme aplikovaním funkcie MERGE na vhodné podproblémy. Toto delenie funguje rovnako ako pri algoritme {\em merge sort}. Funkcia COMPUTE\_SILHOUETTE zoberie ako argument množinu reprezentácii budov. Ak táto množina obsahuje jednu budovu, tak ju vráti. Ak dve budovy, zavolá na nich MERGE a vráti výsledok. Ak viac, rozdelí množinu na dve rovnaké (s rozdielom jednej budovy v prípade nepárneho počtu) množiny, rekurzívne sa na oboch zavolá a výsledok znovu spojí pomocou MERGE a vráti. Týmto spôsobom funkcia COMPUTE\_SILHOUETTE vždy vráti merge všetkých spojich argumentov (merge nezávisí na poradí). \\
\\
Zložitosť závisí na počte MERGE operácii a veľkosti ich vstupu. Na každej úrovni rekurzie je suma veľkosti všetkých reprezentácií rovnaká ($n$ dĺžky 2 na začiatku vs dve dlhé $n$ na konci, kde $n$ je počet budov) a počet úrovní je $\log_2 n$. Výsledná zložitosť je teda $\mathcal{O}(n \log n)$

\pagebreak

%----------------------------------------------------------------------------------------
%	Príklad 2
%----------------------------------------------------------------------------------------

\section*{Príklad 2}

Pre každý vstupný reťazec urobí algoritmus všetky možné rozdelenia tohto reťazca na 2 časti.
Na prvú časť reťazca bude znova aplikovaná funkcia IS\_SENTENCE, kým na druhú časť bude aplikovaná funkcia DICT.
Na výsledky volaní týchto funkcií aplikujeme operátor logický súčin a uložíme do poľa items.
V prípade, že aspoň jeden prvok z poľa items obsahuje hodnotu true, pôvodný reťazec je možné rozdeliť na slová zo slovníka.
Pre zefektívnenie algoritmu využijeme pri funkcii logical\_and tzv. Short-circuit evaluation.



\begin{algorithmic}[1]
    \Function{is\_sentence}{$w[1..n]$}
        \State items = [] of boolean
        \State items.add(DICT(w[1..n]));
        \For{i = 1 to n}
        	\State item = DICT(w[i + 1 .. n]) logical\_and IS\_SENTENCE(w[1 .. i]);
		\State items.add(item);
        \EndFor
        \State \Return apply logical\_or on items;
    \EndFunction
\end{algorithmic}
\ \\

Predstavme si nasledovný prípad
Na vstup dostane algoritmus reťazec o dĺžke n.
Pri overovaní jednotlivých rozdelení nájde slovo o dĺžke a (a zároveň sa rekurzívne zanorí na prefixe o dĺžke (n-a)) a ďalej pokračuje v overovaní ďalších rozdelení (s prefixami dĺžky (n-a+1),(n-a+2),...).

Algoritmus sa rekurzívne zavolá na reťazci o dĺžke n-a.
Pri týchto volaniach však overuje prefixy s dĺžkami 1 .. n-a. Tieto prefixy však overoval aj predošlý priechod algoritmu.

Môžeme povedať, že volanie funkcie IS\_SENTENCE aplikované na reťazci dĺžky n je závislé na všetkých možných volaniach funkcie IS\_SENTENCE aplikovaných na prefixoch tohto reťazca.

Z tohoto dôvodu je výhodné, ak vypočítame IS\_SENTENCE na prefixoch pôvodného reťazca a výsledky týchto volaní si uložíme do rovnomenného asociatívneho poľa.
Kľúč tohto poľa bude tvorený prefixom pôvodného reťazca, hodnota bude typu boolean.


\begin{algorithmic}[1]
    \Function{VERIFY\_SENTENCE}{$w[1..n]$}
    	\For{i = 1 .. n}
    		\State subresults = [] of boolean;
			\State subresults.add(DICT(w[1..i]));
				\For{j = 1 .. i - 1}
					\State subresult = IS\_SENTENCE(w[1 .. j]) logical\_and DICT(w[j + 1 .. i - i]);
					\State subresults.add(subresult);
				\EndFor
			\State \Return IS\_SENTENCE(w[1..i]) = apply logical\_or on subresults;
		\EndFor
		\State \Return IS\_SENTENCE(w[1..n]);
    \EndFunction
	
\end{algorithmic}
\ \\
 
Korektnosť: 

Konvergencia:
Prvy cyklus sa vykoná pre každý prefix slova w.
V cykle sa hodnota premennej i reprezentujucej dlžku prefixu pri každom priechode zvýši o 1 a iterovanie skončí, keď premenná i dosiahne hodnotu n.

Vnorený cyklus sa vykoná pre každý prefix tohto prefixu. 

Jediné miesta, u ktorých hrozí, že algoritmus nezastaví, sú volania cyklov.

V cykle s iterujúcou premennou j sa zaručene pri každom priechode zvýši hodnota premennej j a iterovanie skončí, keď premenná j dosiahne hodnotu i-1.

Parciálna korektnosť:
Dôkaz, že algoritmus vráti true pri validnej postupnosti slov pomocou matematickej indukcie:
1.) S0 = w0 je veta ktorá sa skladá z jedného slova w0 (w0 sa nachádza v slovníku). Pre takúto vetu vráti algoritmus true. Dôvod: položky subresults pre prvok IS\_SENTENCE(w0) budú obsahovať položku dict(w0), ktorá sa vyhodnotí na true. Na položky je aplikovaná funkcia logiký súčet a pretože obsahujú minimálne jednu položku z hodnotou true, algoritmus vráti true.
	
2.) Predpokladáme, že pre vetu s1 zloženú z k slov: s1 = w1.w2...wk vráti korektnú odpoveď true.
	Predpokldáme, že pre vetu s2 zloženú s2 = s1.w(k +1) algoritmus taktiež vráti true.
	Jeden z prefixov vety s2 musí byť reťazec zložený zo slov w1...wk.
	Keďže algoritmus prechádza všetky prefixy, nastane situácia, jedna z položiek v poli subresults
	pre prvok s2 bude IS\_SENTENCE(s1) logical_and dict(w(k+1)).
	
	
Dôkaz, že algoritmus vráti true pri nevalidnej postupnosti slov

	
	
	
	
	
	



 
Zložitosť:
Cyklus s iterujúcou premennou i bude vykonaný n krát.

Vnorený cyklus s iterujúcou premennou j bude vykonaný (i-1) krát, a plaží, že (i-1) < n. Všetky operácie použité v ňom majú konštantnú zložitosť.
Volanie apply logical\_or on subresults bude mať rovnakú zložitosť ako vnorený cyklus (vzhľadom k tomu, že počet jeho položiek zodpovedá počtu iterácií).

$\mathcal{O}(n^2)$

\pagebreak

%----------------------------------------------------------------------------------------
%	Príklad 3
%----------------------------------------------------------------------------------------

\section*{Príklad 3}

Vstupom algoritmu bude:
pole pravdepodobností: $C[p(1),..,p(n)]$\\
$k$ - počet padnutých orlov\\
PVD - pravdepodobnostná funkcia\\

Problém je možné definovať nasledovne: 
vypočíť pravdepodobnosť, že v poli padne k orlov z n mincí

táto pravdepodobnosť je ekvivaletná súčtu pravdepodobností nasledovných prípadov:

1.) pravdepodobnosť prípadu, že posledná minca bude orol
táto pravdepodobnosť je ekvivalentná súčinu čísla p(n) a pravdepodobnosti, že medzi prvými n-1 mincami bude k-1 orlov

2.) pravdepodobnosť prípadu, že posledná minca nebude orol
táto pravdepodobnosť je ekvivalentná súčinu čísla (1-p(n)) a pravdepodobnosti, že medzi prvými n-1 mincami bude k orlov

Tento poznatok nám umožňuje definovať jednoduchý rekurzívny algoritmus (v ktorm zároveň ošetrujeme krajné prípady n=k a n=0)

\begin{algorithmic}[1]
    \Function{PVD}{C[p1,..,pn],k}
        \If{k=0}
            \State \Return PVD(C[p(1),..,p(n-1)],0)*(1-p(n));
        \EndIf
        \If{k=n}
            \State \Return PVD(C[p(1),..,p(n-1)],k-1)*p(n);
        \EndIf
        \State \Return PVD(C[p(1),..,p(n-1)],k-1)*p(n) + PVD(C[p(1),..,p(n-1)],k)*(1-p(n));
    \EndFunction
\end{algorithmic}
\ \\

Ak rozpíšeme vetvenie algoritmu vykonávanie bude vyzerať približne nasledovne
PVD(C[p(1),..,p(n)],k) = PVD(C[p(1),..,p(n-1)],k-1)*p(n) + PVD(C[p(1),..,p(n-1)],k)*(1-p(n))

PVD(C[p(1),..,p(n-1)],k) = PVD(C[p(1),..,p(n-1)],k-1)*p(n-1) + PVD(C[p(1),..,p(n-1)],k)*(1-p(n-1))

PVD(C[p(1),..,p(n-1)],k-1) = PVD(C[p(1),..,p(n-1)],k-2)*p(n-1) + PVD(C[p(1),..,p(n-1)],k-1)*(1-p(n-1))

...
Z predchádzajúceho zápisu volaní funkcií je možné vidieť, že PVD(C[p(1),..,p(n-1)],k-1) sa zavolá 2 krát na jednej úrovni rekurzívneho stromu.
Využijeme techniku dynamického programovania, aby sme sa vyhli opakovanému volaniu funkcie PVD na rovnakých parametroch.
Z algoritmu je zreteľné, že volanie funkcie PVD, ktorá berie ako parameter pole o dĺžke a, je závislá výlučne na volaniach funkcií PVD, ktoré berú ako parameter pole o dĺžke a-1.
Z tohoto dôvodu je výhodné, ak vypočítame najprv. funkcie s parametrami PVD(C[p(1)],0), PVD(C[p(1)],1), PVD(C[p(1),p(2)],0),... ,ich výsledky si budem ukladať do asociatívneho poľa a postupným volaním sa dopracujem k hodnote PVD(C[p(1),..,p(n)],k), ktorá je výsledkom celého problému.
Pre tento účel vytvoríme asociatívne pole s názvom PVD, v ktorom kľúče budú mať tvar:
(C[p(1),..,p(n)],k)
a hodnoty budú obsahovať napočítanú pravdepodobnosť.
Na naplnenie tohto poľa vytvoríme jednoduchú nerekurzívnu funkciu:


\begin{algorithmic}[1]
	\Function{countPVD}{C[p1,..,pn],k}
		\State PVD([p(1)],0) = p1
		\State PVD([p(1)],1) = (1-p1);

		\For{i = 1 .. n}
			\State bottom = max(0,k-(n-i));
			\State up = min(i,k);
			\For{j = bottom .. up}
				\If{k=0}
					\State PVD(C[p(1),..,p(i-1)],0)*(1-p(i));
				\Else \If{k=n}
					\State PVD(C[p(1),..,p(i-1)],j-1)*p(i);
				\Else 
					\State PVD(C[p(1),..,p(i-1)],j-1)*p(i) + PVD(C[p(1),..,p(i-1)],j)*(1-p(i));
				\EndIf \EndIf
			\EndFor
		\EndFor
		\State \Return PVD(C[p(1),..,p(n-1)],k);
	\EndFunction
\end{algorithmic}
\ \\
Zložitosť:
Cyklus s iterujúcou premennou i sa vykoná n krát.
V ňom sa vnorený cyklus iterujúcou premennou j vykoná vždy (up - bottom) krát.
V každom cykle bude hodnota premennej bottom minimálne 0 a hodnota premennej up maximálne k, z čoho vyplýva, že počet týchto cyklov bude maximálne k.
Je zaručené, že k < n a teda zložitosť celého algoritmu bude patriť do triedy $\mathcal{O}(n^2)$


\pagebreak

%----------------------------------------------------------------------------------------
%	Príklad 4
%----------------------------------------------------------------------------------------

\section*{Príklad 4}

rekurzívny algoritmus

\begin{algorithmic}[1]
\Function{best\_price}{n,freePlaces[]}
    \If{n == 0}
        \State \Return 0
    \EndIf

    \State values = [] of number

    \For{i = 1 .. freePlaces.size} 		
        \If{freePlaces[i] != 0}		
            \State freePlacesCopy = copy of freePlaces;			
            \State	freePlacesCopy[i] = freePlacesCopy[i] - 1;			
            \State values[i] = best\_price(n-1,freePlacesCopy) + C[n][i];
        \EndIf
    \EndFor

    \State \Return max(values);
\EndFunction
\end{algorithmic}

\subsection*{Technika dynamického programovania}

Vytvorím štruktúru bestPriceData, ktorá bude typu asociatívne pole
kľúče budú typu Pair<Integer,Integer []>
(lastIndexOfC,freePlaces [])
prvá hodnota oznaèuje index riadku v poli C
druhá hodnota bude typu pole, jeho dĺžka bude zodpovedať počtu autosalónov
hodnota na indexe i bude zodpovedať počtu áut, ktoré je možné ešte predať do autosalónu s číslom $i$

a = počet autosalónov

hodnoty budú typu Pair<Integer,Integer []>
(price,distribution [])
prvá hodnota značí vypočítanú najlepšiu celkovú cenu
druhá hodnota bude typu pole, jeho dåžka bude zodpovedať počtu riadkov v poli C,
hodnoty v čom budú slúžiť na určenie toho, do ktorého salónu bude predané auto s indexom na ktorom je prvok umiestnený
0 bude značiť, že auto zatiaľ nie je priradené do žiadneho salónu, 1 až a bude značiť konkrétny autosalón




// sum = numberOfCars
// threshold = carsPerShop
Vypocita vsetky rozdelenia daneho poctu aut k autosalonom pre 1 to bude [100] [010] [001]
findSpecialPermutations(sum,threshold) do
	if(sum = 0) return [0,0,0]
	permutations = [] of [];
	bottom1 = max(0,sum - 2*threshold);
	upper1 = min(sum,threshold);
	
	for i = bottom1 .. upper1 do
		permutation = [] of length 3
		permutation[1] = i;
		
		bottom2 = max(0,sum - i - threshold);
		upper2 = min(sum - i,threshold);
		
		for j=bottom2 .. upper2 do
			permutation[2] = j;
			permutation[3] = sum - (i+j);
		od
		
		
		permutations.add(permutation);
	od	
	return permutations;
od




\begin{algorithmic}[1]
\Function{countBestPrice}{C}
	bestPriceData(0,[0,0,0]) = 0;
    \For{i = 1 .. C.rows}				
        \State permutations = findSpecialPermutations(i,C.rows/3);
		
	items = [] of number;
		
        \For{permutation in permutations}		
            
	    \For{ j = 1 .. permutation.size}
                \State modifiedPermutation = copy of permutation
		\If{modifiedPermutation[j]>0}
		    \State modifiedPermutation[j] = modifiedPermutation[j] - 1;
		    items.add(bestPrice(i-1,modifiedPermutation) + C[i][j]);
                 \EndIf
            \EndFor			
		
            \State bestPrice[(i,permutation)] = max(items);		
        \EndFor
    \EndFor
    \State \Return bestPrice with key(C.rows);
\EndFunction
\end{algorithmic}


\begin{algorithmic}[1]
\Function{countBestPrice}{C}
    \For{i = 1 .. C.rows}		
        \State combinations = nájdeme všetky kombinácie práve a císel z N0, ktoré sú menšie ako C.rows a, ktoré dávajú súčet i;
        \Comment{každý prvok bude zoznam o dlžke a}				
        \State permutations = []
        
	\For{combination in combinations}
	    \State perm = všetky permutácie zoznamu combination
	    \State permutations.addAll(perm);
        \EndFor
		
        \For{permutation in permutations}		
            \State items = [] of (price,distribution [])
	    \If{hasLastToFill(freePlaces)}
                \State indexOf1 = index of number 1 in array
                \State chosenItems is array of 0;
                \State fill chosenItems with values of 0;
                \State chosenItems[1] = indexOf1;
                \State \Return (C[1][indexOf1],chosenItems);
            \EndIf
            
	    \For{ j = 1 .. permutation.size}
                \State modifiedPermutation = copy of permutation
		\If{modifiedPermutation[j]>0}
		    \State modifiedPermutation[j] = modifiedPermutation[j] - 1;
		    \State	item it;
		    \State aPrice = bestPrice(i-1,modifiedPermutation);
		    \State it.price = aPrice.price + C[i][j];
		    \State it.distribution = aPrice.distribution;
		    \State it.distribution[i] = j;
                    \State items.add(it)
                 \EndIf
            \EndFor			
		
            \State highestValueIndex = index najvacsej hodnoty spomedzi items.price;
            \State bestPrice[(i,permutation)] = items[highestValueIndex];		
        \EndFor
    \EndFor
    \State \Return bestPrice with key(C.rows);
\EndFunction
\end{algorithmic}

Konvergencia



Parciálna korektnosť



\pagebreak

%----------------------------------------------------------------------------------------
%	Príklad 5
%----------------------------------------------------------------------------------------

\section*{Príklad 5}

Hladový algoritmus nenájde správne riešenie pre druhý a tretí problém. \\
Protipríklad: \\
Dokument s dĺžkou riadku: 12 \\
Zoznam slov obsahuje slová s dĺžkami 5,4,4,12 \\

Algoritmus umiestni slová nasledovne: \\
5,4 \\
4 \\
12 \\

Druhý slovný problém: \\
Celková penalizácia bude $3^2 + 8^2 + 0 = 9 + 64 = 73$ \\

Optimálne riešenie je však: \\
5 \\
4,4 \\
12 \\
pri ktorom bude celková penalizácia $7^2 + 4^2 = 49 + 16 = 64$ \\

Tretí slovný problém: \\
Celková penalizácia bude: max(3,8,0) = 8 \\

Optimálne riešenie je však: \\
5 \\
4,4 \\
12 \\
pri ktorom bude celková penalizácia max(7,4,0) = 7 \\

\end{document}
