%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
% \usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[slovak]{babel} % Slovak language/hyphenation
\usepackage[utf8]{inputenc}
% \usepackage[IL2]{fontenc}
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{algpseudocode}
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
\normalfont \normalsize 
\textsc{IV003, Fakulta Informatiky, Masarykova Univerzita} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge Homework 1 \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Jakub Senko, Štefan Uherčík} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	Príklad 1
%----------------------------------------------------------------------------------------

\section*{Príklad 1}

Nech $X = [x_1, x_2, x_3, \dots, x_n]$ je pole cisel dlzky $n, n > 0$ a plati ze $\forall x,y \in X: x \neq y$. \\
Kazdemu $x_i \in X$ je priradene cislo $w_i$, pre ktore plati:
\begin{equation}
    \begin{aligned}
        w_i > 0 \\
        \sum_{i = 0}^{n} w_i = 1
    \end{aligned}
\end{equation}
{\em Optimalny prvok} postupnosti je cislo $x_k$ pre ktore plati:

\begin{equation}
    \begin{aligned}
        \sum_{x_i < x_k} w_i < \frac{1}{2} \\
        \sum_{x_i > x_k} w_i \leq \frac{1}{2}
    \end{aligned}
\end{equation}

Problemom je navrh algoritmu ktory riesi najdenie optimalneho prvku s casovou zlozitostou $\Theta(n)$ a poskytnutie dokazu jeho korektnosti a zlozitosti. \\
\\
Navrhovane riesenie je modifikovany algoritmus {\em Quick Select} ktory riesi problem najdenia medianu v poli cisel. Tento algoritmus ma obecne zlozitost $\mathcal{O}(n^2)$ pri nevhodnej volbe pivota, avsak pomocou procedury {\em Median of Medians} je mozne najst dostatocne dobry pivot na to, aby mal algoritmus vzdy linearnu zlozitost.  {\em Quick Select} je popisany v nasledujucom texte iba neformalne, s odkazom na relevantne zdroje s dokazom zlozitosti. Zadana uloha  je vyriesena ukazanim redukcie problemu najdenia optimalneho prvku na problem rieseny algoritmom {\em Quick Select + Median of Medians} \cite{blum} a dokazom ze tato procedura je vykonatelna v konstantom case. Vysledna zlozitost je teda $\mathcal{O}(n)$. \\
\\
Quick Select \\
Vrati index n-teho najmensieho prvku pola, rekurzivne hlada v casti ohranicenej indexami left a right (vratane).

\begin{algorithmic}[1]
    \Function{quick\_select}{$list$, $left$, $right$, $n$}
%        \If{$left = right$}
%            \State \Return $list[left]$
%        \EndIf
       	\State $pivot \gets$ \Call{random\_between}{$left$, $right$}
        \State $pivot \gets$ \Call{partition}{$list$, $left$, $right$, $pivot$}
        \If{$n = pivot$}
            \State \Return $list[n]$
        \ElsIf{$n < pivot$}
            \State \Return \Call{quick\_select}{$list$, $left$, $pivot - 1$, $n$}
        \Else
            \State \Return \Call{quick\_select}{$list$, $pivot + 1$, $right$, $n$}
        \EndIf
    \EndFunction
\end{algorithmic}

Quick Select bezi v $\mathcal{O}(n^2)$. \\

Ako by bolo mozne deterministicky vybrat dobry pivot tak, aby bol vysledny algoritmus vzdy linearny.\\

Median Of Medians

Median of medians: http://www.youtube.com/watch?v=QAbv\_4ndfo4\&list=PLLH73N9cB21W1TZ6zz1dLkyIm50HylGyg \\

\begin{algorithmic}[1]
    \Function{median\_of\_medians}{$list$, $left$, $right$}
        \State $groups \gets$ \Call{split\_into\_groups\_of}{$list$, $left$, $right$, $5$}
        \State $medians \gets$ \Call{new\_list}{}
        \ForAll{$group \in groups$}
            \State $median \gets$ \Call{median\_of\_5}{$group$}
            \State \Call{add}{$medians$, $median$}
        \EndFor
       \State $size \gets$ \Call{size}{$medians$}
       \State \Return \Call{quick\_select}{$medians$, $0$, $size$, $\frac{n}{2}$}
    \EndFunction
\end{algorithmic}

Rozdelenie do skupin po 5 je O(n) ale najdenie medianu z konstantneho poctu prvkov je O(1).
Nahradime funkciu {\em random\_between} pouzitu na ziskanie indexu pivota algoritmom {\em median\_of\_medians}. Nahradenie sposobi problem pretoze MOM vracia hodnotu a QS ocakava index, ale QS mozeme upravit aby vracal index linearnym vyhladanim danej hodnoty v poli. Takto upraveny algoritmus bude obsahovat dve rekurzivne volania. Jedno vo funkcii MoM (riadok 9, zlozitost je n/5 pretoze sme ziskali n/5 medianov) a druhe priamo v QS (riadok 7 alebo 8). Druhe volanie ma zlozitost 7/10n zodpovedajuce hornemu odhadu poctu prvkov ktore su vacsie alebo naopak mensie ako median medianov (TODO ref. slidy). Ostatne operacie su konstantne alebo linearne.
Nasledujuca rekurentna rovnica vyjadruje celkovu zlozitost QS (kde c je konstanta - pocet operacii s linearnou zlozitostou):

\begin{equation}
    \begin{aligned}
        T(n) = T\left(\frac{n}{5}\right) + T\left(\frac{7n}{10}\right)+c.n \\
        T(n) = 10.c.n \in \Theta(n)
    \end{aligned}
\end{equation}

Redukcia spociva v doplnujucej operacii ktora pre obidve particie zoznamu rozdeleneho podla pivota spocita sucet $w_i$.
Tieto opracie su znovy vykonatelne v linearnom case. Vysledne sucty urcia na ktorej particii sa algoritmus rekurzivne zavola, pripadne ak plati podmienka pre optimalny prvok postupnosti, vypocet skonci. To znamena ze parameter mozeme odstranit parameter $n$ ktory je po tejto uprave nepotrebny (kazda postupnost ma unikatny optimalny prvok). Vysledny upraveny algoritmus je nasledovny:

\begin{algorithmic}[1]
    \Function{quick\_select\_mom}{$list$, $left$, $right$}
       	\State $pivotIndex \gets$ \Call{median\_of\_medians\_index}{$list$, $left$, $right$}
        \State $pivotIndex \gets$ \Call{partition}{$list$, $left$, $right$, $pivotIndex$}
        \State $sumBottom \gets$ \Call{sum\_w}{$list$, $0$, $pivotIndex - 1$}
        \State $sumTop \gets$ \Call{sum\_w}{$list$, $pivotIndex + 1$, $length(list)$}
        \If{$sumBottom \geq \frac{1}{2}$}
            \State \Return \Call{quick\_select\_mom}{$list$, $left$, $pivotIndex - 1$}
        \ElsIf{$sumTop > \frac{1}{2}$}
            \State \Return \Call{quick\_select\_mom}{$list$, $pivotIndex + 1$, $right$}
        \Else
            \State \Return $list[n]$
        \EndIf
    \EndFunction \\
    \Function{quick\_select\_mom\_start}{$list$}
    	\State \Return \Call{quick\_select\_mom}{$list$, $1$, $lenght(list)$}    
    \EndFunction
\end{algorithmic}

Korektnost: \\
Vstupna podmienka $\phi(\langle X \rangle)$ je urcena vztahom (0.1) v zadani problemu.\\
Vystupna podmienka $\psi(\langle X \rangle, x_k)$ pozaduje, ze vystup algoritmu, $x_k$, je {\em optimalny prvok} podla vztahu (0.2).
Parcialna korektnost \\
Vyuzijeme dokaz matematickou indukciou. Zjednodusime ze funkciu median of medians budeme brat ako korektny sposob najdenia medianu (slidy) aj napriek tomu ze obsahuje rekurzivne volanie do tejto procedury. Ak dokazeme korektnost v tomto zjednodusenom pripade, dokazeme to aj pre MOMI. 

Zakladom indukcie bude nasledujuca myslienka:
Pocas priebehu algoritmu (na zaciatku) je pole $X = [x_0, x_1, x_2, \dots, x_n], n > 0$ rozdelene na tri sekcie (left < right): \\
$X_{left} = [x_1, x_2, x_3, \dots, x_{left-1}]$\\
$X_{mid} = [x_{left}, \dots, x_{right}]$\\
$X_{right} = [x_{right+1}, \dots, x_n]$\\
Tvrdim, ze pre kazde volanie funkcie QSMOM plati, ze:\\
$\forall x_i \in X_{left}, \forall x_j \in X_{mid}, x_i < x_j$ and $ \sum w_i < \frac{1}{2} \\$ \\
podobne \\
$\forall x_j \in X_{mid}, \forall x_k \in X_{right}, x_j < x_k$ and $ \sum w_k \leq \frac{1}{2} \\$ \\

Pokial dokazeme, ze velkost $X_{mid}$ v kazdom rekurzivnom zavolani funkcie klesne (konvergenciu dokazeme potom), dostaneme sa postupne k casti ktora bude obsahovat prave jeden prvok. Pretoze pren budu platit vyssie uvedene podmienky, bude sa jednat o hladany {\em optimalny prvok postupnosti}. Indukciu budeme teda viest vzhladom k velkosti $X_{mid}$.

Pred samotnym dokazom je potrebne poznamenat, ze predpokladame ze procedury median of median index, partition a um pokladame za totalne korektne. Kedze upraveny algoritmus vychadza z existujucich algoritmov popisanych v predchadzajucom texte ktore tiez pouzivaju dane procedury, ich dokaz je mozne vyhladat v existujucich zdrojoch.

Zaklad indukcie:
Pri zavolani funkcie quick select mom start (prve volanie QSMoM) je rozdelenie na tri sekcie nasledovne:
$X_{left} = []$\\
$X_{mid} = [x_1, x_2, \dots, x_{n-1}, x_n]$\\
$X_{right} = []$\\
Trivialne tvrdenie plati. \\

Indukcny krok:\\n
Predpokladame ze pre $k$-te rekurzivne volanie tvrdenie plati na zaciatku funkcie. Analyzujme prebeh funkcie aby sme dokazali ze to bude platit aj pri nasledujucom rekurzivnom volani a zaroven $|X_{mid_k}| > |X_{mid_{k+1}}| $
V prvom kroku zvolime pivot a ziskame jeho index. Funkcia vrati hodnotu pre ktoru plati: $left \leq pivotIndex \leq right$. Prpominam ze implementacia tejto funkcie nie je podstatna pre korektnost algortmu ale len pre jeho efektivitu. [todo PICK] V druhom kroku sa vola funkcia partition, ktora rozdeli $X_{mid}$ na dve particie:\\
$X_{lower} = [x_{left}, \dots, x_{pivotIndex-1}]$ \\
$X_{upper} = [x_{pivotIndex+1}, \dots, x_{right}]$ \\
Pre ktore plati:
$\forall x \in X_{lower}, x < x_{pivotIndex}$ a $\forall x \in X_{lower}, x \geq x_{pivotIndex}$
Tato funkcia je prebrana z existujucich algoritmov Quick Select, Quick Sort apod. a teda nie je potrebne dokazovat jej korektnost.
Dalsie dva kroky spocitaju sumu vah vsetkych prvkov v zozname nalavo a potom napravo od pivota, teda: \\

V tomto momente su uz k dispozicii vsetky informacie a nasleduje podmienene vetvenie ktore v dvoch pripadoch rekurzivne zavola danu funkciu a v jednom vrati konkretny vysledok. Budem sa teraz venovat prvym dvom moznostiam a dokazem ze v tychto pripadoch plati indukcna hypoteza a poslednej moznosti sa budem venovat v dalsej sekcii.

Ak plati ze $sumBottom \geq \frac{1}{2}$ potom bude rekurzivne nove rozdelenie nasledujuce: \\
$X_{left_{k+1}} = X_{left_k}$ \\
$X_{mid_{k+1}} = X_{lower_k}$\\
$X_{right_{k+1}} = [x_{pivotIndex}] \sqcup X_{upper_k} \sqcup X_{right_k}$

V tomto pripade plati ze vsetky prvky v left su mensie nez vsetky z mid trivialne, pretoze $X_{left_{k+1}} = X_{left_k}$ a $X_{mid_{k+1}} \sqsubset X_{mid_{k}}$ a teda to vyplyva priamo z ind. hypotezy. To iste plati pre sumu $X_{left_{k+1}}.
$X_{right_{k+1}} sa sklada z pivota a $X_{upper_k}$ ktore su vacsie ako $X_{mid_{k+1}} co priamo vyplyva zo specifikacie pre partition funkciu. Pre $X_{right_k}$ to vyplyva z indukcnej hypotezy.
To ze je sucet mensi ako jedna polovica vyplyva zo zadania ktore pozaduje aby bol sucet vah prave jedna. Kedze z podmienky ktora sposobila vetvenie plati ze $sumBottom \geq \frac{1}{2}$ > 1/2 a right tvori zvysok zoznamu, potom jeho suma musi byt mensia ako 1/2. Indukcia plati.

V druhom pripade

Konvergencia a parcialna korektnost:\\
Zlozitost: \\

\pagebreak
%----------------------------------------------------------------------------------------
%	Príklad 2
%----------------------------------------------------------------------------------------

\section*{Príklad 2}

\subsection{Example of list (3*itemize)}
\begin{itemize}
	\item First item in a list 
		\begin{itemize}
		\item First item in a list 
			\begin{itemize}
			\item First item in a list 
			\item Second item in a list 
			\end{itemize}
		\item Second item in a list 
		\end{itemize}
	\item Second item in a list 
\end{itemize}

%------------------------------------------------

\subsection{Example of list (enumerate)}
\begin{enumerate}
\item First item in a list 
\item Second item in a list 
\item Third item in a list
\end{enumerate}

%----------------------------------------------------------------------------------------

<<<<<<< Updated upstream
\pagebreak
%----------------------------------------------------------------------------------------
%	Príklad 3
%----------------------------------------------------------------------------------------

\section*{Príklad 3}

\pagebreak
%----------------------------------------------------------------------------------------
%	Príklad 4
%----------------------------------------------------------------------------------------

\section*{Príklad 4}

\textbf{Tvrdenie 1}: Ľubovoľná postupnosť n operácií INSERT  a MIN-ALL má zložitosť O(n). \\

Uvažujme prirodzené čísla n,k a l, pre ktoré platí n=k+l (n vyjadruje počet operácií)

\[ l = \left\{ 
  \begin{array}{l l}
    \frac{n}{2} & \quad \text{ak $n$ je párne}\\
    \frac{n-1}{2} & \quad \text{ak $n$ is nepárne}
  \end{array} \right.\]

\[ l = \left\{ 
  \begin{array}{l l}
    \frac{n}{2} & \quad \text{ak $n$ je párne}\\
    \frac{n-1}{2} + 1 & \quad \text{ak $n$ is nepárne}
  \end{array} \right.\]


Uvažujme $k$ oprácií INSERT, každá z týchto operácií vloží do zoznamu rovnaké prirodzené číslo z.
Po poslednej z týchto operácií bude mať zoznam dĺžku $k$. \\

Cena týchto operácií dohromady je $k$. \\

Po týchto operáciách nasleduje $l$ operácií MIN-ALL.
Všetky čísla v zozname sú rovnaké, teda všetky čísla v ňom sú minimálne.
Znamená to, že pri žiadnom z volaní operácie MIN-ALL sa dĺžka zoznamu nezmení.


Cena týchto operácií bude 
\[ l*k = \left\{ 
  \begin{array}{l l}
    \frac{n}{2}* \frac{n}{2} = \frac{n^2}{4} & \quad \text{ak $n$ je párne}\\
    \frac{n-1}{2}* (\frac{n}{2} + 1) = \frac{n^2}{4} + \frac{n}{4} - \frac{1}{2} & \quad \text{ak $n$ is nepárne}
  \end{array} \right.\]

Z predošlého tvrdenia vyplýva, že špecifikovaná postupnosť operácií bude minimimálne v zložitostnej triede O(n), teda tvrdenie \textbf{neplatí}. \\

\textbf{Tvrdenie 2}: Ľubovoľná postupnosť n operácií INSERT  a MIN-ONE má zložitosť O(n). \\
Príklad riešime pomocou metódy účtov, kredity pre jednotliv0 operácie stanovíme nasledovne \\

  \begin{tabular}{ | l | c | r | }
    \hline
    Operácia & Cena & Kredit \\	
    \hline
    INSERT & 1 & 2 \\ 
    MIN-ONE & |S| & 1 \\
    \hline
  \end{tabular}\\

Platí, že vždy počas výpočtu je veľkosť zoznamu rovná počtu kreditov na účte, teda počet kreditov nikdy nebude menší ako 0.
Celkový kredit po vykonaní n operácií bude menší alebo rovný 2n, teda tvrdenie \textbf{platí}. \\


\textbf{Tvrdenie 3}: Ľubovoľná postupnosť n operácií INSERT a DELETE má zložitosť O(n). \\

Uvažujme prirodzené čísla n,k a l, pre ktoré platí n=k+l (n vyjadruje počet operácií
Hodnotu čísel k a l stanovíme rovnako, ako pri tvrdení 1.

Uvažujme $k$ oprácií INSERT, každá z týchto operácií vloží do zoznamu rovnaké prirodzené číslo z.
Po poslednej z týchto operácií bude mať zoznam dĺžku $k$. \\

Cena týchto operácií dohromady je $k$. \\

Po týchto operáciách nasleduje $l$ operácií DELETE(y), pričom platí, že y$\neq$z. To má za dôsledok, že po žiadnej z týchto operácií sa dĺžka zoznamu nezmení. Cena týchto operácií bude rovnaká, ako v tvrdení 1.
Tvrdenie preto \textbf{neplatí}.

\textbf{Tvrdenie 4}: Ľubovoľná postupnosť n operácií INSERT a DELETE taká, že pri každom volaní sa operácia DELETE volá s iným parametrom $i$, má zložitosť má zložitosť O(n). \\

Uvažujme prirodzené čísla n,k a l, pre ktoré platí n=k+l (n vyjadruje počet operácií).
Hodnotu čísel k a l stanovíme rovnako, ako pri tvrdení 1.

Uvažujme $k$ oprácií INSERT, každá z týchto operácií vloží do zoznamu rovnaké prirodzené číslo z.
Po poslednej z týchto operácií bude mať zoznam dĺžku $k$. \\

Cena týchto operácií dohromady je $k$. \\

Špecifikujeme množinu M o veľkosti $l$, v ktorej sa nachádzajú prirodzené čísla odližné od $z$.
Vykonáme $l$ operácií DELETE, pričom pri každej jej volaní predložíme ako parameter iný prvok z množiny M.
To bude mať za následok, že veľkosť zoznamu sa nezmení. Cena týchto operácií bude rovnaká, ako v tvrdení 1.
Tvrdenie preto \textbf{neplatí}.





\pagebreak
%----------------------------------------------------------------------------------------
%	Príklad 5
%----------------------------------------------------------------------------------------

\section*{Príklad 5}
\begin{thebibliography}{1}
\bibitem{blum} BLUM, Manuel, Robert W. FLOYD, Vaughan PRATT, Ronald L. RIVEST a Robert E. TARJAN.
Time bounds for selection.
Journal of Computer and System Sciences. 1973, vol. 7, issue 4, s. 448-461.
DOI: 10.1016/S0022-0000(73)80033-9.
Dostupné z: http://linkinghub.elsevier.com/retrieve/pii/S0022000073800339

\bibitem{foo} http://moonflare.com/code/select/select.pdf
\end{thebibliography}

\end{document}
